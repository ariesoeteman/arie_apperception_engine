module Main where

import qualified Control.Monad as Monad
import qualified Data.Char as Char
import qualified Data.Graph as Graph
import qualified Data.List as List
import qualified Data.Map as Map
import qualified Data.Maybe as Maybe
import qualified Data.Set as Set
import qualified System.Environment as Environment
import qualified System.Process as Process
import qualified System.Random as Random

import HouseTypes
import HouseData



-------------------------------------------------------------------------------
-- Simulator
-------------------------------------------------------------------------------

example_to_trajectory :: Example -> Trajectory
example_to_trajectory e = List.reverse ms where
    ms = List.foldl' update_trajectory b (actions e)
    b = [(initial_state e, ActionNoop)]

initial_state :: Example -> State    
initial_state e = State { house = h, sensors = ss, pos = p, window_size = ws } where
    h = initial_house e
    p = initial_pos e
    ws = initial_window_size e
    ss = get_sensors (initial_house e) p ws

get_sensors :: [String] -> Pos -> Pos -> [[Int]]
get_sensors h p ws = ss where
    (px, py) = p
    (wx, wy) = ws
    ss = map f [py .. py+wy-1]
    f y = map (g y) [px .. px+wx-1]
    g y x = case get_c x y of
        '.' -> 0
        'X' -> 1
    get_c x y = (h !! y) !! x

update_trajectory :: Trajectory -> Action -> Trajectory   
update_trajectory ((s,_) : t) a = ((s',ActionNoop) : (s,a) : t) where
    s' = perform_action s a

state_to_strings :: State -> [String]
state_to_strings s = pt : wt : map f (sensors s) where
    pt = "Pos: " ++ show (pos s)
    wt = "Window: " ++ show (window_size s)
    f r = concat $ List.intersperse " " (map show r) 

perform_action :: State -> Action -> State
perform_action s ActionNoop = s
perform_action s ActionLeft = move_man s (-1, 0)
perform_action s ActionRight = move_man s (1, 0)
perform_action s ActionUp = move_man s (0, -1)
perform_action s ActionDown = move_man s (0, 1)

move_man :: State -> (Int, Int) -> State
move_man s (dx, dy) = s { pos = pos', sensors = ss } where
    (mx, my) = pos s
    mx' = mx + dx
    my' = my + dy
    pos' = (mx', my')
    ss = get_sensors (house s) pos' (window_size s)

-------------------------------------------------------------------------------
-- Output
-------------------------------------------------------------------------------

main :: IO ()
main = do
    write_symbolic_single_experiment
    Monad.forM_ house_examples $ \(t, e) -> write_example t e

write_symbolic_single_experiment :: IO ()
write_symbolic_single_experiment = do
    let f = "scripts/single_house.sh"
    putStrLn $ "Generating file " ++ f
    writeFile f (unlines gen_single_experiment)
    let c = "chmod 777 " ++ f
    Process.callCommand c

gen_single_experiment :: [String]
gen_single_experiment = hs ++ xs ++ ts where
    hs = ["#!/bin/bash", "", "case $(expr $1 + 1) in"]
    ts = ["esac"]
    xs = concat (map f (zip [1..] house_examples))
    f (n, (f, _)) = ["\t" ++ show n ++ " )", "\t\techo \"Solving house example " ++ f ++ "...\"", "\t\ttime code/solve house " ++ f, "\t\t;;"]

write_example :: String -> Example -> IO ()
write_example title e = do
    let f = "data/house/house_" ++ title ++ ".lp"
    let ss = example_to_symbolic_strings e
    writeFile f (unlines ss)

do_example :: Example -> IO ()    
do_example e = Monad.forM_ (example_to_symbolic_strings e) putStrLn

example_to_symbolic_strings :: Example -> [String]
example_to_symbolic_strings e = let t = example_to_trajectory e in
    comments t ++ trajectory_atoms t ++ exogenous_atoms t ++ elements t ++ concepts ++ times t ++ exists_uniques ++ xors ++ cell_adjacency t

comments :: Trajectory -> [String]
comments t = header ++ concat (map f (t')) ++ [line, ""] where
    t' = zip [1..] t
    header = line : "% Generated by House.hs" : line : "% " : []
    f (i, (s, a)) = g i : "% " : map ("% " ++ ) (state_to_strings s ++ ["", show a, ""])
    g i = "% Time " ++ show i ++ ":"
    line = "%--------------------------------------------------"

trajectory_atoms :: Trajectory -> [String]
trajectory_atoms t = h : concat (map f (zip [1..] t)) ++ [""] where
    h = "% The given sequence"
    f (i, x) | i >= length t = state_atoms "hidden" (i, x) 
    f (i, x) | otherwise = state_atoms "senses" (i, x) 

state_atoms :: String -> (Int, (State, Action)) -> [String]
state_atoms prd (t, (s, _)) = "" : concat (map f (zip [1..] (sensors s))) where
    f (y, r) = map (g y) (zip [1..] r)
    g y (x, v) = prd ++ "(s2(c_intensity, obj_v_c_" ++ show x ++ "_" ++ show y ++ ", obj_number_" ++ show v ++ "), " ++ show t ++ ")."

exogenous_atoms :: Trajectory -> [String]
exogenous_atoms t = "% Exogenous actions" : map f (zip [1..] t) ++ [""] where
    f (i, (_, a)) = "exogenous(s(c_" ++ show a ++ ", obj_man), " ++ show i ++ ")."

elements :: Trajectory -> [String]
elements ((s,_):_) = h : vs ++ ws ++ [""] where
    h = "% Elements"
    (vx, vy) = window_size s
    (wx, wy) = (length (house s !! 0), length (house s))
    vs = concat (map f [1 .. vx])
    f i = map (g i) [1 .. vy]
    g i j = "is_object(obj_v_c_" ++ show i ++ "_" ++ show j ++ ")."
    ws = concat (map f2 [1 .. wx])
    f2 i = map (g2 i) [1 .. wy]
    g2 i j = "is_object(obj_w_c_" ++ show i ++ "_" ++ show j ++ ")."

concepts :: [String]
concepts = "% Concepts" : map f ss ++ [""] where
    f s = "is_concept(" ++ s ++ ")."
    ss = ["right", "below", "is_zero", "is_one", "in", "on", "off", "intensity", "noop", "north", "south", "east", "west"]

times :: Trajectory -> [String]
times t = ["% Time", "is_time(1.." ++ show (length t) ++ ").", ""]

exists_uniques :: [String]
exists_uniques = concat (map f d) where
    d = [
        ("c_in", "t_v_cell", "t_w_cell"),
        ("c_intensity", "t_v_cell", "t_nat")
        ]
    f (i, j, k) = exists_unique i j k

exists_unique :: String -> String -> String -> [String]
exists_unique p t t2 = [
    "% ∃! clause for " ++ p ++ " : at most one",
    ":-",
    "\tholds(s2(" ++ p ++ ", X, Y), T),",
    "\tholds(s2(" ++ p ++ ", X, Y2), T),",
    "\tY != Y2.",
    "",
    "% ∃! clause for "++ p ++ " : at least one",
    ":-",
    "\tpermanent(isa(" ++ t ++ ", X)),",
    "\tis_time(T),",
    "\tnot aux_" ++ p ++ "(X, T).",
    "",
    "aux_" ++ p ++ "(X, T) :-",
    "\tholds(s2(" ++ p ++ ", X, _), T).",
    "",
    "% Incompossibility for " ++ p,
    "incompossible(s2(" ++ p ++ ", X, Y), s2(" ++ p ++ ", X, Y2)) :-",
    "\tpermanent(isa(" ++ t ++ ", X)),",
    "\tpermanent(isa(" ++ t2 ++ ", Y)),",
    "\tpermanent(isa(" ++ t2 ++ ", Y2)),",
    "\tY != Y2.",
    ""
    ]

xors :: [String]
xors = action_text

action_text :: [String]
action_text = [
    "",
    "% Exclusions",
    "% Every action is either noop, north, south, east, or west",
    "% ∀X : man, noop(X) ⊕ north(X) ⊕ south(X) ⊕ east(X) ⊕ west(X)",
    "",
    "% At most one"
    ]
    ++ concat (map at_most_one all_action_pairs) ++ [""] ++ 
    [
    "% At least one",
    ":-",
    "\tpermanent(isa(t_man, X)),",
    "\tis_time(T),",
    "\tnot holds(s(c_noop, X), T),",
    "\tnot holds(s(c_north, X), T),",
    "\tnot holds(s(c_south, X), T),",
    "\tnot holds(s(c_east, X), T),",
    "\tnot holds(s(c_west, X), T).",
    "",
    "% Incompossibility"
    ]
    ++ concat (map incompossible all_action_pairs) ++ [""]

at_most_one :: (String, String) -> [String]
at_most_one (a1, a2) = [
    ":-",
    "\tholds(s(" ++ a1 ++ ", X), T),",
    "\tholds(s(" ++ a2 ++ ", X), T)."
    ]

incompossible :: (String, String) -> [String]
incompossible (a1, a2) = [
    "incompossible(s(" ++ a1 ++ ", X), s(" ++ a2 ++ ", X)) :-",
    "\tpermanent(isa(t_man, X)).",
    ""
    ]

all_action_pairs :: [(String, String)]    
all_action_pairs = [(a1, a2) | a1 <- actions, a2 <- actions, a1 < a2] where
    actions = ["c_noop", "c_north", "c_south", "c_east", "c_west"]

instance Show State where
    show = unlines . state_to_strings

cell_adjacency :: Trajectory -> [String]
cell_adjacency ((s,_):_) = "% Cell adjacency" : p_rights b ++ p_belows b ++ [""] where
    b = house_size s

house_size :: State -> (Int, Int)
house_size s = (x, y) where
    x = length (house s!! 0)
    y = length (house s)

p_rights :: (Int, Int) -> [String]
p_rights (bx, by) = concat (map f [1 .. by]) where
    f y = map (g y) [1 .. bx-1]
    g y x = "permanent(isa2(p_right, obj_w_c_" ++ show x ++ "_" ++ show y ++ ", obj_w_c_" ++ show (x+1) ++ "_" ++ show y ++ "))."

p_belows :: (Int, Int) -> [String]
p_belows (bx, by) = concat (map f [1 .. by-1]) where
    f y = map (g y) [1 .. bx]
    g y x = "permanent(isa2(p_below, obj_w_c_" ++ show x ++ "_" ++ show y ++ ", obj_w_c_" ++ show x ++ "_" ++ show (y+1) ++ "))."
