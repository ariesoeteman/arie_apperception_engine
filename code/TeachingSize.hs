module Main where

import qualified Control.Monad as Monad
import qualified Data.List as List
import qualified Data.Map as Map
import qualified Data.Maybe as Maybe
import qualified System.Random as Random
import System.Process as Process

import System.Environment

type Seq = (Int, String, Int)

all_sequences :: [Seq]
all_sequences = concat (map f (zip [1..] sequences)) where
    f (n, s) = map (g n s) [1 .. length s - 1]
    g n s i = (n, s, i)

sequences :: [String]
sequences = [
    "000000000000000000000000000000",
    "010101010101010101010101010101",
    "101010101010101010101010101010",
    "111111111111111111111111111111",
    "001010101010101010101010101010",
    "010000000000000000000000000000",
    "010010010010010010010010010010",
    "011011011011011011011011011011",
    "011111111111111111111111111111",
    "100000000000000000000000000000",
    "100100100100100100100100100100",
    "101101101101101101101101101101",
    "101111111111111111111111111111",
    "110101010101010101010101010101",
    "110110110110110110110110110110",
    "000101010101010101010101010101",
    "001000000000000000000000000000",
    "001001001001001001001001001001",
    "001101101101101101101101101101",
    "001111111111111111111111111111",
    "010001000100010001000100010001",
    "010110110110110110110110110110",
    "010111111111111111111111111111",
    "011000000000000000000000000000",
    "011001100110011001100110011001",
    "011010101010101010101010101010",
    "011101110111011101110111011101",
    "100010001000100010001000100010",
    "100101010101010101010101010101",
    "100110011001100110011001100110",
    "100111111111111111111111111111",
    "101000000000000000000000000000",
    "101001001001001001001001001001",
    "101100110110001101100110110000",
    "101110111011101110111011101110",
    "110000000000000000000000000000",
    "110010010010010010010010010010",
    "110011001100110011001100110011",
    "110111111111111111111111111111",
    "111010101010101010101010101010",
    "111011101110111011101110111011",
    "000001000000010000000100000001",
    "000010000000100000001000000010",
    "000010101010101010101010101010",
    "000011000001100000110000011000",
    "000100010001000100010001000100",
    "000100100100100100100100100100",
    "000110110110110110110110110110",
    "000111111111111111111111111111",
    "001000100010001000100010001000",
    "001001100100111001001100100111",
    "001011011011011011011011011011",
    "001100000000000000000000000000",
    "001100110011001100110011001100",
    "001101010101010101010101010101",
    "001110111011101110111011101110",
    "010000100001000010000100001000",
    "010011001001110010011001001111",
    "010011111111111111111111111111",
    "010100001010000101000010100001",
    "010100100111100100011001010010",
    "010110011011000110110011011000",
    "010111011101110111011101110111",
    "011000110001100011000110001100",
    "011001010101010101010101010101",
    "011100111001110011100111001110",
    "011101010101010101010101010101",
    "011110111101111011110111101111",
    "100010101010101010101010101010",
    "100011000110001100011000110001",
    "100110101010101010101010101010",
    "100111001110011100111001110011",
    "101000100010001000100010001000",
    "101001100100111001001100100111",
    "101011011101111011111011111101",
    "101011110101111010111101011110",
    "101111011110111101111011110111",
    "110001000100010001000100010001",
    "110001100011000110001100011000",
    "110010101010101010101010101010",
    "110011111111111111111111111111",
    "110100000000000000000000000000",
    "110110011011000110110011011000",
    "110111011101110111011101110111",
    "111000000000000000000000000000",
    "111001001001001001001001001001",
    "111001110011100111001110011100",
    "111011011011011011011011011011",
    "111100111110011111001111100111",
    "111101010101010101010101010101",
    "111101111111011111110111111101",
    "111110111111101111111011111110",
    "000000100001000010000100001000",
    "000001010101010101010101010101",
    "000001100000110000011000001100",
    "000010000100001000010000100001",
    "000010010010010010010010010010",
    "000010110110110110110110110110",
    "000011011011011011011011011011",
    "000100001000010000100001000010"
    ]

main :: IO ()
main = do
    Monad.forM_ all_sequences output_seq
    --write_single_experiment

k_folder :: String
k_folder = "teaching-size/"

output_seq :: Seq -> IO ()    
output_seq (task, s, cutoff) = do
    let f = "data/" ++ k_folder ++ "predict_" ++ show task ++ "_" ++ show cutoff ++ ".lp"
    putStrLn $ "Using sequence: " ++ s ++ " with cutoff " ++ show cutoff
    putStrLn $ "Creating file: " ++ f
    writeFile f "%------------------------------------------------------------------------------\n"
    appendFile f $ "% This file was generated using sequence " ++ s ++ "\n"
    appendFile f $ "% with cutoff " ++ show cutoff ++ "\n"
    appendFile f "%------------------------------------------------------------------------------\n"
    appendFile f "\n"
    appendFile f "% The given sequence\n"
    Monad.forM_ (zip [0..] s) $ \(t, x) -> case t < cutoff of
        True -> appendFile f $ "senses(s(c_" ++ [x] ++ ", obj_sensor), " ++ show (t+1) ++ ").\n"
        False -> appendFile f $ "hidden(s(c_" ++ [x] ++ ", obj_sensor), " ++ show (t+1) ++ ").\n"
    appendFile f "\n"
    appendFile f "% Elements\n"
    appendFile f "is_object(obj_sensor).\n"
    let ts = map show [1 .. length s]
    appendFile f $ "is_time(" ++ concat (List.intersperse ";" ts) ++ ").\n"
    appendFile f "\n"
    appendFile f "% Every sensor is either c_0 or c_1\n"
    appendFile f "% S : sensor → c_0(S) ⊕ c_1(S)\n"
    appendFile f "\n"
    appendFile f "% At most one\n"
    appendFile f ":-\n"
    appendFile f "\tholds(s(c_0, X), T),\n"
    appendFile f "\tholds(s(c_1, X), T).\n"
    appendFile f "\n"
    appendFile f "% At least one\n"
    appendFile f ":-\n"
    appendFile f "\tpermanent(isa(t_sensor, X)),\n"
    appendFile f"\tis_time(T),\n"
    appendFile f "\tnot holds(s(c_0, X), T),\n"
    appendFile f "\tnot holds(s(c_1, X), T).\n"
    appendFile f "\n\n"
    appendFile f "% Incompossibility\n"
    appendFile f "incompossible(s(c_0, X), s(c_1, X)) :-\n"
    appendFile f "\tpermanent(isa(t_sensor, X)).\n"


write_single_experiment :: IO ()
write_single_experiment = do
    let f = "scripts/single_book.sh"
    writeFile f (unlines (gen_single_experiment (zip [1..] all_sequences)))
    let c = "chmod 777 " ++ f
    Process.callCommand c

gen_single_experiment :: [(Int, Seq)] -> [String]
gen_single_experiment seqs = hs ++ xs ++ ts where
    hs = ["#!/bin/bash", "", "case $(expr $1 + 1) in"]
    ts = ["esac"]
    xs = concat (map f seqs)
    f (n, (task, _, cutoff)) = ["\t" ++ show n ++ " )", "\t\techo \"Solving " ++ show task ++ " with " ++ show cutoff ++ " cutoff...\"", "\t\ttime code/solve book predict_" ++ show task ++ "_" ++ show cutoff ++ ".lp", "\t\t;;"]
                    
